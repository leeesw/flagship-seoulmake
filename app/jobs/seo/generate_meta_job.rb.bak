# app/jobs/seo/generate_meta_job.rb
module Seo
  class GenerateMetaJob
    include Sidekiq::Job
    sidekiq_options queue: :llm_seo

    VERSION = 1 # 알고리즘/포맷 바뀌면 올리세요

    def perform(post_id, mode = "apply")
      gate = Atr::PipelineGate.new(pipeline: "wp-seo", version: VERSION)

      # 1) 대상 글 로드 (이미 가져오고 있다면 그 객체 재사용)
      post = Atr::WpClient.get_post(post_id, context: :view) # 필요 시 구현/호출부 맞추세요
      title_raw = post.dig("title", "raw") || post.dig("title", "rendered") || ""
      html_raw  = post.dig("content", "raw") || post.dig("content", "rendered") || ""

      # 2) 체크섬 계산
      checksum = gate.checksum_for(title: title_raw, html: html_raw)

      # 3) 스킵 게이트
      if gate.skip?(post_id: post_id, checksum: checksum) && mode != "force"
        Sidekiq.logger.info("[wp-seo] skip post=#{post_id} ver=#{VERSION} checksum=#{checksum[0,8]}")
        return
      end

      # 4) --- 기존 SEO 생성/업데이트 로직 ---
      #     (타이틀/디스크립션/OG/Twitter 생성 및 WP 반영)
      #     Atr::WpClient.put_meta!(...) 또는 RankMath API 호출 등
      #     ...

      # 5) 완료 마킹
      gate.mark!(post_id: post_id, checksum: checksum)
      Sidekiq.logger.info("[wp-seo] mark post=#{post_id} ver=#{VERSION} checksum=#{checksum[0,8]}")
    rescue => e
      Sidekiq.logger.error("[wp-seo] error post=#{post_id}: #{e.class}: #{e.message}")
      raise
    end
  end
end
