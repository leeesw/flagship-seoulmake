# frozen_string_literal: true
#
# config/initializers/wp_bridge_upload_compat.rb
#
# Purpose:
# - Provide a real WordPress REST uploader for media (POST /wp/v2/media)
# - Provide helpers to set featured image and RankMath social images
# - Provide a meta_versions(reader) used by Runner (seo_ver / fi_ver)
#
# NOTE: This file *reopens* Atr::WpBridge and adds methods. It does not replace
#       your existing constructor or other logic.

require "net/http"
require "uri"
require "json"
require "securerandom"
require "base64"

module Atr
  class WpBridge
    # -- Public: Upload a media file via WP REST (/wp/v2/media)
    # Returns: { id: Integer, source_url: String, raw: Hash }
    def upload_media!(file_path:, filename: nil, title: nil, alt: nil, mime: nil)
      raise "file not found: #{file_path}" unless File.exist?(file_path)

      base = _resolve_api_base!
      uri  = URI.parse("#{base}/media")

      user, pass = _resolve_basic_auth!
      boundary = "----atr#{SecureRandom.hex(8)}"

      fn  = (filename && !filename.empty?) ? filename : File.basename(file_path)
      mt  = mime.to_s.empty? ? _mime_type_from_ext(fn) : mime
      bin = File.binread(file_path)

      parts = []
      parts << _build_file_part("file", fn, mt, bin, boundary)
      parts << _build_field_part("title",     title, boundary) if title && !title.empty?
      parts << _build_field_part("alt_text",  alt,   boundary) if alt   && !alt.empty?
      parts << "--#{boundary}--\r\n"
      body = parts.join

      req = Net::HTTP::Post.new(uri)
      req["Authorization"] = "Basic #{Base64.strict_encode64("#{user}:#{pass}")}"
      req["Content-Type"]  = "multipart/form-data; boundary=#{boundary}"
      req["Accept"]        = "application/json"
      req.body = body

      res = _http(uri) { |h| h.request(req) }
      raise "HTTP #{res.code}: #{res.body}" unless res.is_a?(Net::HTTPSuccess)

      json = JSON.parse(res.body)
      { id: json["id"], source_url: json["source_url"], raw: json }
    end

    # -- Public: Set featured image (post thumbnail) via WP REST
    # Accepts keyword args or positional for compatibility.
    # Returns: true on success
    def set_featured_media(post_id, attachment_id)
      base = _resolve_api_base!
      uri  = URI.parse("#{base}/posts/#{post_id}")

      user, pass = _resolve_basic_auth!
      req = Net::HTTP::Post.new(uri)
      req["Authorization"] = "Basic #{Base64.strict_encode64("#{user}:#{pass}")}"
      req["Content-Type"]  = "application/json"
      req["Accept"]        = "application/json"
      req.body = { featured_media: Integer(attachment_id) }.to_json

      res = _http(uri) { |h| h.request(req) }
      raise "HTTP #{res.code}: #{res.body}" unless res.is_a?(Net::HTTPSuccess)
      true
    end
    alias set_featured         set_featured_media
    alias set_post_thumbnail   set_featured_media
    alias set_featured_image   set_featured_media

    # -- Public: Set RankMath OG/Twitter image URLs via meta
    # image_url: absolute URL (we use URL, not ID, for broad compatibility)
    # Returns: true on success
    def set_rankmath_social_images(post_id:, image_url:)
      base = _resolve_api_base!
      uri  = URI.parse("#{base}/posts/#{post_id}")

      user, pass = _resolve_basic_auth!
      req = Net::HTTP::Post.new(uri)
      req["Authorization"] = "Basic #{Base64.strict_encode64("#{user}:#{pass}")}"
      req["Content-Type"]  = "application/json"
      req["Accept"]        = "application/json"

      # Rank Math commonly exposes these meta keys to REST.
      # If not registered for REST, WP may ignore them (safe no-op).
      req.body = {
        meta: {
          "rank_math_facebook_image" => image_url,
          "rank_math_twitter_image"  => image_url
        }
      }.to_json

      res = _http(uri) { |h| h.request(req) }
      # Some setups may return 200 with filtered meta; treat non-2xx as error.
      raise "HTTP #{res.code}: #{res.body}" unless res.is_a?(Net::HTTPSuccess)
      true
    end
    # Convenience aliases
    def set_social(post_id:, image_url:)
      set_rankmath_social_images(post_id: post_id, image_url: image_url)
    end
    alias set_social_image set_social

    # -- Public: read custom version meta for Runner
    # Returns: { seo: Integer, fi: Integer }
    def meta_versions(post_id)
      base = _resolve_api_base!
      uri  = URI.parse("#{base}/posts/#{post_id}?context=edit")

      user, pass = _resolve_basic_auth!
      req = Net::HTTP::Get.new(uri)
      req["Authorization"] = "Basic #{Base64.strict_encode64("#{user}:#{pass}")}"
      req["Accept"]        = "application/json"

      res = _http(uri) { |h| h.request(req) }
      raise "HTTP #{res.code}: #{res.body}" unless res.is_a?(Net::HTTPSuccess)

      json = JSON.parse(res.body)
      meta = (json["meta"] || {})

      {
        seo: Integer(meta["seo_ver"] || meta["atr_seo_ver"] || meta["sm_seo_ver"] || 0) rescue 0,
        fi:  Integer(meta["fi_ver"]  || meta["atr_fi_ver"]  || meta["sm_fi_ver"]  || 0) rescue 0
      }
    end

    private

    # ---- helpers -------------------------------------------------------------

    def _resolve_api_base!
      # Preference: Atr::Config.wp_api_base → ENV → Atr::Config.base + /wp-json/wp/v2
      if defined?(Atr::Config) && Atr::Config.respond_to?(:wp_api_base) && !Atr::Config.wp_api_base.to_s.empty?
        Atr::Config.wp_api_base.to_s
      elsif ENV["WP_API_BASE"].to_s != ""
        ENV["WP_API_BASE"].to_s
      elsif defined?(Atr::Config) && Atr::Config.respond_to?(:base) && !Atr::Config.base.to_s.empty?
        "#{Atr::Config.base.to_s.sub(%r{/\z}, "")}/wp-json/wp/v2"
      else
        raise "WP API base missing (set WP_API_BASE or ATR_BASE)"
      end
    end

    def _resolve_basic_auth!
      user =
        if defined?(Atr::Config) && Atr::Config.respond_to?(:wp_user) && !Atr::Config.wp_user.to_s.empty?
          Atr::Config.wp_user
        else
          ENV["WP_USER"] || ENV["WP_USERNAME"]
        end

      pass =
        if defined?(Atr::Config) && Atr::Config.respond_to?(:wp_app_pw) && !Atr::Config.wp_app_pw.to_s.empty?
          Atr::Config.wp_app_pw
        else
          ENV["WP_APP_PW"] || ENV["WP_PASSWORD"]
        end

      raise "WP credentials missing" if user.to_s.empty? || pass.to_s.empty?
      [user, pass]
    end

    def _http(uri)
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = (uri.scheme == "https")
      http.open_timeout = 20
      http.read_timeout = 60
      http.start { yield http }
    end

    def _build_field_part(name, value, boundary)
      "--#{boundary}\r\n" \
      "Content-Disposition: form-data; name=\"#{name}\"\r\n\r\n" \
      "#{value}\r\n"
    end

    def _build_file_part(name, filename, mime, binary, boundary)
      "--#{boundary}\r\n" \
      "Content-Disposition: form-data; name=\"#{name}\"; filename=\"#{filename}\"\r\n" \
      "Content-Type: #{mime}\r\n\r\n" \
      "#{binary}\r\n"
    end

    def _mime_type_from_ext(filename)
      ext = File.extname(filename).downcase
      case ext
      when ".png"          then "image/png"
      when ".jpg", ".jpeg" then "image/jpeg"
      when ".webp"         then "image/webp"
      when ".gif"          then "image/gif"
      else                       "application/octet-stream"
      end
    end
  end
end
